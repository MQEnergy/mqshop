// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/MQEnergy/mqshop/internal/app/model"
)

func newProductGoods(db *gorm.DB, opts ...gen.DOOption) productGoods {
	_productGoods := productGoods{}

	_productGoods.productGoodsDo.UseDB(db, opts...)
	_productGoods.productGoodsDo.UseModel(&model.ProductGoods{})

	tableName := _productGoods.productGoodsDo.TableName()
	_productGoods.ALL = field.NewAsterisk(tableName)
	_productGoods.ID = field.NewInt64(tableName, "id")
	_productGoods.UUID = field.NewString(tableName, "uuid")
	_productGoods.GoodsTitle = field.NewString(tableName, "goods_title")
	_productGoods.GoodsSubtitle = field.NewString(tableName, "goods_subtitle")
	_productGoods.CateID = field.NewInt64(tableName, "cate_id")
	_productGoods.BrandID = field.NewInt64(tableName, "brand_id")
	_productGoods.AttrCateID = field.NewInt64(tableName, "attr_cate_id")
	_productGoods.ThumbURL = field.NewString(tableName, "thumb_url")
	_productGoods.PhotoUrls = field.NewString(tableName, "photo_urls")
	_productGoods.OriginPrice = field.NewFloat64(tableName, "origin_price")
	_productGoods.PromotePrice = field.NewFloat64(tableName, "promote_price")
	_productGoods.FinalPrice = field.NewFloat64(tableName, "final_price")
	_productGoods.TotalStock = field.NewInt(tableName, "total_stock")
	_productGoods.IsHot = field.NewInt8(tableName, "is_hot")
	_productGoods.IsNew = field.NewInt8(tableName, "is_new")
	_productGoods.IsRecommend = field.NewInt8(tableName, "is_recommend")
	_productGoods.SortOrder = field.NewInt(tableName, "sort_order")
	_productGoods.Status = field.NewInt8(tableName, "status")
	_productGoods.CreatedAt = field.NewInt64(tableName, "created_at")
	_productGoods.UpdatedAt = field.NewInt64(tableName, "updated_at")

	_productGoods.fillFieldMap()

	return _productGoods
}

// productGoods 商品表
type productGoods struct {
	productGoodsDo

	ALL           field.Asterisk
	ID            field.Int64
	UUID          field.String  // 唯一id号
	GoodsTitle    field.String  // 商品标题
	GoodsSubtitle field.String  // 商品小标题
	CateID        field.Int64   // 分类ID
	BrandID       field.Int64   // 品牌ID
	AttrCateID    field.Int64   // 属性分类ID
	ThumbURL      field.String  // 商品缩略图图片
	PhotoUrls     field.String  // 商品相册图列表
	OriginPrice   field.Float64 // 商品原价
	PromotePrice  field.Float64 // 商品促销价
	FinalPrice    field.Float64 // 商品最终价
	TotalStock    field.Int     // 总库存
	IsHot         field.Int8    // 是否热门 1：热门 0：正常
	IsNew         field.Int8    // 是否新品 1：新品 0：正常
	IsRecommend   field.Int8    // 是否推荐 1：热门 0：正常
	SortOrder     field.Int     // 排序
	Status        field.Int8    // 状态 1：正常 0：下架
	CreatedAt     field.Int64
	UpdatedAt     field.Int64

	fieldMap map[string]field.Expr
}

func (p productGoods) Table(newTableName string) *productGoods {
	p.productGoodsDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p productGoods) As(alias string) *productGoods {
	p.productGoodsDo.DO = *(p.productGoodsDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *productGoods) updateTableName(table string) *productGoods {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewInt64(table, "id")
	p.UUID = field.NewString(table, "uuid")
	p.GoodsTitle = field.NewString(table, "goods_title")
	p.GoodsSubtitle = field.NewString(table, "goods_subtitle")
	p.CateID = field.NewInt64(table, "cate_id")
	p.BrandID = field.NewInt64(table, "brand_id")
	p.AttrCateID = field.NewInt64(table, "attr_cate_id")
	p.ThumbURL = field.NewString(table, "thumb_url")
	p.PhotoUrls = field.NewString(table, "photo_urls")
	p.OriginPrice = field.NewFloat64(table, "origin_price")
	p.PromotePrice = field.NewFloat64(table, "promote_price")
	p.FinalPrice = field.NewFloat64(table, "final_price")
	p.TotalStock = field.NewInt(table, "total_stock")
	p.IsHot = field.NewInt8(table, "is_hot")
	p.IsNew = field.NewInt8(table, "is_new")
	p.IsRecommend = field.NewInt8(table, "is_recommend")
	p.SortOrder = field.NewInt(table, "sort_order")
	p.Status = field.NewInt8(table, "status")
	p.CreatedAt = field.NewInt64(table, "created_at")
	p.UpdatedAt = field.NewInt64(table, "updated_at")

	p.fillFieldMap()

	return p
}

func (p *productGoods) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *productGoods) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 20)
	p.fieldMap["id"] = p.ID
	p.fieldMap["uuid"] = p.UUID
	p.fieldMap["goods_title"] = p.GoodsTitle
	p.fieldMap["goods_subtitle"] = p.GoodsSubtitle
	p.fieldMap["cate_id"] = p.CateID
	p.fieldMap["brand_id"] = p.BrandID
	p.fieldMap["attr_cate_id"] = p.AttrCateID
	p.fieldMap["thumb_url"] = p.ThumbURL
	p.fieldMap["photo_urls"] = p.PhotoUrls
	p.fieldMap["origin_price"] = p.OriginPrice
	p.fieldMap["promote_price"] = p.PromotePrice
	p.fieldMap["final_price"] = p.FinalPrice
	p.fieldMap["total_stock"] = p.TotalStock
	p.fieldMap["is_hot"] = p.IsHot
	p.fieldMap["is_new"] = p.IsNew
	p.fieldMap["is_recommend"] = p.IsRecommend
	p.fieldMap["sort_order"] = p.SortOrder
	p.fieldMap["status"] = p.Status
	p.fieldMap["created_at"] = p.CreatedAt
	p.fieldMap["updated_at"] = p.UpdatedAt
}

func (p productGoods) clone(db *gorm.DB) productGoods {
	p.productGoodsDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p productGoods) replaceDB(db *gorm.DB) productGoods {
	p.productGoodsDo.ReplaceDB(db)
	return p
}

type productGoodsDo struct{ gen.DO }

type IProductGoodsDo interface {
	gen.SubQuery
	Debug() IProductGoodsDo
	WithContext(ctx context.Context) IProductGoodsDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IProductGoodsDo
	WriteDB() IProductGoodsDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IProductGoodsDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IProductGoodsDo
	Not(conds ...gen.Condition) IProductGoodsDo
	Or(conds ...gen.Condition) IProductGoodsDo
	Select(conds ...field.Expr) IProductGoodsDo
	Where(conds ...gen.Condition) IProductGoodsDo
	Order(conds ...field.Expr) IProductGoodsDo
	Distinct(cols ...field.Expr) IProductGoodsDo
	Omit(cols ...field.Expr) IProductGoodsDo
	Join(table schema.Tabler, on ...field.Expr) IProductGoodsDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IProductGoodsDo
	RightJoin(table schema.Tabler, on ...field.Expr) IProductGoodsDo
	Group(cols ...field.Expr) IProductGoodsDo
	Having(conds ...gen.Condition) IProductGoodsDo
	Limit(limit int) IProductGoodsDo
	Offset(offset int) IProductGoodsDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IProductGoodsDo
	Unscoped() IProductGoodsDo
	Create(values ...*model.ProductGoods) error
	CreateInBatches(values []*model.ProductGoods, batchSize int) error
	Save(values ...*model.ProductGoods) error
	First() (*model.ProductGoods, error)
	Take() (*model.ProductGoods, error)
	Last() (*model.ProductGoods, error)
	Find() ([]*model.ProductGoods, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ProductGoods, err error)
	FindInBatches(result *[]*model.ProductGoods, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ProductGoods) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IProductGoodsDo
	Assign(attrs ...field.AssignExpr) IProductGoodsDo
	Joins(fields ...field.RelationField) IProductGoodsDo
	Preload(fields ...field.RelationField) IProductGoodsDo
	FirstOrInit() (*model.ProductGoods, error)
	FirstOrCreate() (*model.ProductGoods, error)
	FindByPage(offset int, limit int) (result []*model.ProductGoods, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IProductGoodsDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p productGoodsDo) Debug() IProductGoodsDo {
	return p.withDO(p.DO.Debug())
}

func (p productGoodsDo) WithContext(ctx context.Context) IProductGoodsDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p productGoodsDo) ReadDB() IProductGoodsDo {
	return p.Clauses(dbresolver.Read)
}

func (p productGoodsDo) WriteDB() IProductGoodsDo {
	return p.Clauses(dbresolver.Write)
}

func (p productGoodsDo) Session(config *gorm.Session) IProductGoodsDo {
	return p.withDO(p.DO.Session(config))
}

func (p productGoodsDo) Clauses(conds ...clause.Expression) IProductGoodsDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p productGoodsDo) Returning(value interface{}, columns ...string) IProductGoodsDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p productGoodsDo) Not(conds ...gen.Condition) IProductGoodsDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p productGoodsDo) Or(conds ...gen.Condition) IProductGoodsDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p productGoodsDo) Select(conds ...field.Expr) IProductGoodsDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p productGoodsDo) Where(conds ...gen.Condition) IProductGoodsDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p productGoodsDo) Order(conds ...field.Expr) IProductGoodsDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p productGoodsDo) Distinct(cols ...field.Expr) IProductGoodsDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p productGoodsDo) Omit(cols ...field.Expr) IProductGoodsDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p productGoodsDo) Join(table schema.Tabler, on ...field.Expr) IProductGoodsDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p productGoodsDo) LeftJoin(table schema.Tabler, on ...field.Expr) IProductGoodsDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p productGoodsDo) RightJoin(table schema.Tabler, on ...field.Expr) IProductGoodsDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p productGoodsDo) Group(cols ...field.Expr) IProductGoodsDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p productGoodsDo) Having(conds ...gen.Condition) IProductGoodsDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p productGoodsDo) Limit(limit int) IProductGoodsDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p productGoodsDo) Offset(offset int) IProductGoodsDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p productGoodsDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IProductGoodsDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p productGoodsDo) Unscoped() IProductGoodsDo {
	return p.withDO(p.DO.Unscoped())
}

func (p productGoodsDo) Create(values ...*model.ProductGoods) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p productGoodsDo) CreateInBatches(values []*model.ProductGoods, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p productGoodsDo) Save(values ...*model.ProductGoods) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p productGoodsDo) First() (*model.ProductGoods, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductGoods), nil
	}
}

func (p productGoodsDo) Take() (*model.ProductGoods, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductGoods), nil
	}
}

func (p productGoodsDo) Last() (*model.ProductGoods, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductGoods), nil
	}
}

func (p productGoodsDo) Find() ([]*model.ProductGoods, error) {
	result, err := p.DO.Find()
	return result.([]*model.ProductGoods), err
}

func (p productGoodsDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ProductGoods, err error) {
	buf := make([]*model.ProductGoods, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p productGoodsDo) FindInBatches(result *[]*model.ProductGoods, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p productGoodsDo) Attrs(attrs ...field.AssignExpr) IProductGoodsDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p productGoodsDo) Assign(attrs ...field.AssignExpr) IProductGoodsDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p productGoodsDo) Joins(fields ...field.RelationField) IProductGoodsDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p productGoodsDo) Preload(fields ...field.RelationField) IProductGoodsDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p productGoodsDo) FirstOrInit() (*model.ProductGoods, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductGoods), nil
	}
}

func (p productGoodsDo) FirstOrCreate() (*model.ProductGoods, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductGoods), nil
	}
}

func (p productGoodsDo) FindByPage(offset int, limit int) (result []*model.ProductGoods, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p productGoodsDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p productGoodsDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p productGoodsDo) Delete(models ...*model.ProductGoods) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *productGoodsDo) withDO(do gen.Dao) *productGoodsDo {
	p.DO = *do.(*gen.DO)
	return p
}
