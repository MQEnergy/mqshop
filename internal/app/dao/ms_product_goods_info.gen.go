// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"github.com/MQEnergy/mqshop/internal/app/model"
)

func newProductGoodsInfo(db *gorm.DB, opts ...gen.DOOption) productGoodsInfo {
	_productGoodsInfo := productGoodsInfo{}

	_productGoodsInfo.productGoodsInfoDo.UseDB(db, opts...)
	_productGoodsInfo.productGoodsInfoDo.UseModel(&model.ProductGoodsInfo{})

	tableName := _productGoodsInfo.productGoodsInfoDo.TableName()
	_productGoodsInfo.ALL = field.NewAsterisk(tableName)
	_productGoodsInfo.ID = field.NewInt64(tableName, "id")
	_productGoodsInfo.GoodsID = field.NewInt64(tableName, "goods_id")
	_productGoodsInfo.Unit = field.NewString(tableName, "unit")
	_productGoodsInfo.Weight = field.NewFloat64(tableName, "weight")
	_productGoodsInfo.Integral = field.NewInt(tableName, "integral")
	_productGoodsInfo.DetailTitle = field.NewString(tableName, "detail_title")
	_productGoodsInfo.DetailDesc = field.NewString(tableName, "detail_desc")
	_productGoodsInfo.GoodsKeyword = field.NewString(tableName, "goods_keyword")
	_productGoodsInfo.GoodsContent = field.NewString(tableName, "goods_content")
	_productGoodsInfo.ShippingFee = field.NewFloat64(tableName, "shipping_fee")
	_productGoodsInfo.CurMonthSaleNum = field.NewInt(tableName, "cur_month_sale_num")
	_productGoodsInfo.ShippingProvinceID = field.NewInt(tableName, "shipping_province_id")
	_productGoodsInfo.ShippingProvinceName = field.NewString(tableName, "shipping_province_name")
	_productGoodsInfo.ShippingCityID = field.NewInt(tableName, "shipping_city_id")
	_productGoodsInfo.ShippingCityName = field.NewString(tableName, "shipping_city_name")
	_productGoodsInfo.ShippingRemark = field.NewString(tableName, "shipping_remark")
	_productGoodsInfo.GoodsRemark = field.NewString(tableName, "goods_remark")
	_productGoodsInfo.ServiceInfo = field.NewString(tableName, "service_info")
	_productGoodsInfo.IsShow = field.NewInt8(tableName, "is_show")
	_productGoodsInfo.ViewNum = field.NewInt(tableName, "view_num")
	_productGoodsInfo.CollectNum = field.NewInt(tableName, "collect_num")
	_productGoodsInfo.LikeNum = field.NewInt(tableName, "like_num")
	_productGoodsInfo.CreatedAt = field.NewInt64(tableName, "created_at")
	_productGoodsInfo.UpdatedAt = field.NewInt64(tableName, "updated_at")

	_productGoodsInfo.fillFieldMap()

	return _productGoodsInfo
}

// productGoodsInfo 商品详情表
type productGoodsInfo struct {
	productGoodsInfoDo

	ALL                  field.Asterisk
	ID                   field.Int64
	GoodsID              field.Int64   // 商品ID
	Unit                 field.String  // 计量单位
	Weight               field.Float64 // 商品重量 kg
	Integral             field.Int     // 积分
	DetailTitle          field.String  // 详细页标题
	DetailDesc           field.String  // 详细页描述
	GoodsKeyword         field.String  // 商品关键字
	GoodsContent         field.String  // 商品详情
	ShippingFee          field.Float64 // 快递费
	CurMonthSaleNum      field.Int     // 当月销量
	ShippingProvinceID   field.Int     // 商品发货地省份ID
	ShippingProvinceName field.String  // 商品发货地省份名称
	ShippingCityID       field.Int     // 商品发货地城市ID
	ShippingCityName     field.String  // 商品发货地城市名称
	ShippingRemark       field.String  // 配送费标记如：在线支付免运费
	GoodsRemark          field.String  // 商品标记如：可配送海外，店铺发货，7天无理由退货，闪电退款，极速审核等
	ServiceInfo          field.String  // 商品服务如：可配送海外，店铺发货，7天无理由退货，闪电退款，极速审核等
	IsShow               field.Int8    // 商品详情是否展示 1：展示 0：不展示
	ViewNum              field.Int     // 商品浏览数量
	CollectNum           field.Int     // 商品收藏数量
	LikeNum              field.Int     // 商品点赞数量
	CreatedAt            field.Int64
	UpdatedAt            field.Int64

	fieldMap map[string]field.Expr
}

func (p productGoodsInfo) Table(newTableName string) *productGoodsInfo {
	p.productGoodsInfoDo.UseTable(newTableName)
	return p.updateTableName(newTableName)
}

func (p productGoodsInfo) As(alias string) *productGoodsInfo {
	p.productGoodsInfoDo.DO = *(p.productGoodsInfoDo.As(alias).(*gen.DO))
	return p.updateTableName(alias)
}

func (p *productGoodsInfo) updateTableName(table string) *productGoodsInfo {
	p.ALL = field.NewAsterisk(table)
	p.ID = field.NewInt64(table, "id")
	p.GoodsID = field.NewInt64(table, "goods_id")
	p.Unit = field.NewString(table, "unit")
	p.Weight = field.NewFloat64(table, "weight")
	p.Integral = field.NewInt(table, "integral")
	p.DetailTitle = field.NewString(table, "detail_title")
	p.DetailDesc = field.NewString(table, "detail_desc")
	p.GoodsKeyword = field.NewString(table, "goods_keyword")
	p.GoodsContent = field.NewString(table, "goods_content")
	p.ShippingFee = field.NewFloat64(table, "shipping_fee")
	p.CurMonthSaleNum = field.NewInt(table, "cur_month_sale_num")
	p.ShippingProvinceID = field.NewInt(table, "shipping_province_id")
	p.ShippingProvinceName = field.NewString(table, "shipping_province_name")
	p.ShippingCityID = field.NewInt(table, "shipping_city_id")
	p.ShippingCityName = field.NewString(table, "shipping_city_name")
	p.ShippingRemark = field.NewString(table, "shipping_remark")
	p.GoodsRemark = field.NewString(table, "goods_remark")
	p.ServiceInfo = field.NewString(table, "service_info")
	p.IsShow = field.NewInt8(table, "is_show")
	p.ViewNum = field.NewInt(table, "view_num")
	p.CollectNum = field.NewInt(table, "collect_num")
	p.LikeNum = field.NewInt(table, "like_num")
	p.CreatedAt = field.NewInt64(table, "created_at")
	p.UpdatedAt = field.NewInt64(table, "updated_at")

	p.fillFieldMap()

	return p
}

func (p *productGoodsInfo) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := p.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (p *productGoodsInfo) fillFieldMap() {
	p.fieldMap = make(map[string]field.Expr, 24)
	p.fieldMap["id"] = p.ID
	p.fieldMap["goods_id"] = p.GoodsID
	p.fieldMap["unit"] = p.Unit
	p.fieldMap["weight"] = p.Weight
	p.fieldMap["integral"] = p.Integral
	p.fieldMap["detail_title"] = p.DetailTitle
	p.fieldMap["detail_desc"] = p.DetailDesc
	p.fieldMap["goods_keyword"] = p.GoodsKeyword
	p.fieldMap["goods_content"] = p.GoodsContent
	p.fieldMap["shipping_fee"] = p.ShippingFee
	p.fieldMap["cur_month_sale_num"] = p.CurMonthSaleNum
	p.fieldMap["shipping_province_id"] = p.ShippingProvinceID
	p.fieldMap["shipping_province_name"] = p.ShippingProvinceName
	p.fieldMap["shipping_city_id"] = p.ShippingCityID
	p.fieldMap["shipping_city_name"] = p.ShippingCityName
	p.fieldMap["shipping_remark"] = p.ShippingRemark
	p.fieldMap["goods_remark"] = p.GoodsRemark
	p.fieldMap["service_info"] = p.ServiceInfo
	p.fieldMap["is_show"] = p.IsShow
	p.fieldMap["view_num"] = p.ViewNum
	p.fieldMap["collect_num"] = p.CollectNum
	p.fieldMap["like_num"] = p.LikeNum
	p.fieldMap["created_at"] = p.CreatedAt
	p.fieldMap["updated_at"] = p.UpdatedAt
}

func (p productGoodsInfo) clone(db *gorm.DB) productGoodsInfo {
	p.productGoodsInfoDo.ReplaceConnPool(db.Statement.ConnPool)
	return p
}

func (p productGoodsInfo) replaceDB(db *gorm.DB) productGoodsInfo {
	p.productGoodsInfoDo.ReplaceDB(db)
	return p
}

type productGoodsInfoDo struct{ gen.DO }

type IProductGoodsInfoDo interface {
	gen.SubQuery
	Debug() IProductGoodsInfoDo
	WithContext(ctx context.Context) IProductGoodsInfoDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IProductGoodsInfoDo
	WriteDB() IProductGoodsInfoDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IProductGoodsInfoDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IProductGoodsInfoDo
	Not(conds ...gen.Condition) IProductGoodsInfoDo
	Or(conds ...gen.Condition) IProductGoodsInfoDo
	Select(conds ...field.Expr) IProductGoodsInfoDo
	Where(conds ...gen.Condition) IProductGoodsInfoDo
	Order(conds ...field.Expr) IProductGoodsInfoDo
	Distinct(cols ...field.Expr) IProductGoodsInfoDo
	Omit(cols ...field.Expr) IProductGoodsInfoDo
	Join(table schema.Tabler, on ...field.Expr) IProductGoodsInfoDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IProductGoodsInfoDo
	RightJoin(table schema.Tabler, on ...field.Expr) IProductGoodsInfoDo
	Group(cols ...field.Expr) IProductGoodsInfoDo
	Having(conds ...gen.Condition) IProductGoodsInfoDo
	Limit(limit int) IProductGoodsInfoDo
	Offset(offset int) IProductGoodsInfoDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IProductGoodsInfoDo
	Unscoped() IProductGoodsInfoDo
	Create(values ...*model.ProductGoodsInfo) error
	CreateInBatches(values []*model.ProductGoodsInfo, batchSize int) error
	Save(values ...*model.ProductGoodsInfo) error
	First() (*model.ProductGoodsInfo, error)
	Take() (*model.ProductGoodsInfo, error)
	Last() (*model.ProductGoodsInfo, error)
	Find() ([]*model.ProductGoodsInfo, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ProductGoodsInfo, err error)
	FindInBatches(result *[]*model.ProductGoodsInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ProductGoodsInfo) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IProductGoodsInfoDo
	Assign(attrs ...field.AssignExpr) IProductGoodsInfoDo
	Joins(fields ...field.RelationField) IProductGoodsInfoDo
	Preload(fields ...field.RelationField) IProductGoodsInfoDo
	FirstOrInit() (*model.ProductGoodsInfo, error)
	FirstOrCreate() (*model.ProductGoodsInfo, error)
	FindByPage(offset int, limit int) (result []*model.ProductGoodsInfo, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IProductGoodsInfoDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (p productGoodsInfoDo) Debug() IProductGoodsInfoDo {
	return p.withDO(p.DO.Debug())
}

func (p productGoodsInfoDo) WithContext(ctx context.Context) IProductGoodsInfoDo {
	return p.withDO(p.DO.WithContext(ctx))
}

func (p productGoodsInfoDo) ReadDB() IProductGoodsInfoDo {
	return p.Clauses(dbresolver.Read)
}

func (p productGoodsInfoDo) WriteDB() IProductGoodsInfoDo {
	return p.Clauses(dbresolver.Write)
}

func (p productGoodsInfoDo) Session(config *gorm.Session) IProductGoodsInfoDo {
	return p.withDO(p.DO.Session(config))
}

func (p productGoodsInfoDo) Clauses(conds ...clause.Expression) IProductGoodsInfoDo {
	return p.withDO(p.DO.Clauses(conds...))
}

func (p productGoodsInfoDo) Returning(value interface{}, columns ...string) IProductGoodsInfoDo {
	return p.withDO(p.DO.Returning(value, columns...))
}

func (p productGoodsInfoDo) Not(conds ...gen.Condition) IProductGoodsInfoDo {
	return p.withDO(p.DO.Not(conds...))
}

func (p productGoodsInfoDo) Or(conds ...gen.Condition) IProductGoodsInfoDo {
	return p.withDO(p.DO.Or(conds...))
}

func (p productGoodsInfoDo) Select(conds ...field.Expr) IProductGoodsInfoDo {
	return p.withDO(p.DO.Select(conds...))
}

func (p productGoodsInfoDo) Where(conds ...gen.Condition) IProductGoodsInfoDo {
	return p.withDO(p.DO.Where(conds...))
}

func (p productGoodsInfoDo) Order(conds ...field.Expr) IProductGoodsInfoDo {
	return p.withDO(p.DO.Order(conds...))
}

func (p productGoodsInfoDo) Distinct(cols ...field.Expr) IProductGoodsInfoDo {
	return p.withDO(p.DO.Distinct(cols...))
}

func (p productGoodsInfoDo) Omit(cols ...field.Expr) IProductGoodsInfoDo {
	return p.withDO(p.DO.Omit(cols...))
}

func (p productGoodsInfoDo) Join(table schema.Tabler, on ...field.Expr) IProductGoodsInfoDo {
	return p.withDO(p.DO.Join(table, on...))
}

func (p productGoodsInfoDo) LeftJoin(table schema.Tabler, on ...field.Expr) IProductGoodsInfoDo {
	return p.withDO(p.DO.LeftJoin(table, on...))
}

func (p productGoodsInfoDo) RightJoin(table schema.Tabler, on ...field.Expr) IProductGoodsInfoDo {
	return p.withDO(p.DO.RightJoin(table, on...))
}

func (p productGoodsInfoDo) Group(cols ...field.Expr) IProductGoodsInfoDo {
	return p.withDO(p.DO.Group(cols...))
}

func (p productGoodsInfoDo) Having(conds ...gen.Condition) IProductGoodsInfoDo {
	return p.withDO(p.DO.Having(conds...))
}

func (p productGoodsInfoDo) Limit(limit int) IProductGoodsInfoDo {
	return p.withDO(p.DO.Limit(limit))
}

func (p productGoodsInfoDo) Offset(offset int) IProductGoodsInfoDo {
	return p.withDO(p.DO.Offset(offset))
}

func (p productGoodsInfoDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IProductGoodsInfoDo {
	return p.withDO(p.DO.Scopes(funcs...))
}

func (p productGoodsInfoDo) Unscoped() IProductGoodsInfoDo {
	return p.withDO(p.DO.Unscoped())
}

func (p productGoodsInfoDo) Create(values ...*model.ProductGoodsInfo) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Create(values)
}

func (p productGoodsInfoDo) CreateInBatches(values []*model.ProductGoodsInfo, batchSize int) error {
	return p.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (p productGoodsInfoDo) Save(values ...*model.ProductGoodsInfo) error {
	if len(values) == 0 {
		return nil
	}
	return p.DO.Save(values)
}

func (p productGoodsInfoDo) First() (*model.ProductGoodsInfo, error) {
	if result, err := p.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductGoodsInfo), nil
	}
}

func (p productGoodsInfoDo) Take() (*model.ProductGoodsInfo, error) {
	if result, err := p.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductGoodsInfo), nil
	}
}

func (p productGoodsInfoDo) Last() (*model.ProductGoodsInfo, error) {
	if result, err := p.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductGoodsInfo), nil
	}
}

func (p productGoodsInfoDo) Find() ([]*model.ProductGoodsInfo, error) {
	result, err := p.DO.Find()
	return result.([]*model.ProductGoodsInfo), err
}

func (p productGoodsInfoDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ProductGoodsInfo, err error) {
	buf := make([]*model.ProductGoodsInfo, 0, batchSize)
	err = p.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (p productGoodsInfoDo) FindInBatches(result *[]*model.ProductGoodsInfo, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return p.DO.FindInBatches(result, batchSize, fc)
}

func (p productGoodsInfoDo) Attrs(attrs ...field.AssignExpr) IProductGoodsInfoDo {
	return p.withDO(p.DO.Attrs(attrs...))
}

func (p productGoodsInfoDo) Assign(attrs ...field.AssignExpr) IProductGoodsInfoDo {
	return p.withDO(p.DO.Assign(attrs...))
}

func (p productGoodsInfoDo) Joins(fields ...field.RelationField) IProductGoodsInfoDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Joins(_f))
	}
	return &p
}

func (p productGoodsInfoDo) Preload(fields ...field.RelationField) IProductGoodsInfoDo {
	for _, _f := range fields {
		p = *p.withDO(p.DO.Preload(_f))
	}
	return &p
}

func (p productGoodsInfoDo) FirstOrInit() (*model.ProductGoodsInfo, error) {
	if result, err := p.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductGoodsInfo), nil
	}
}

func (p productGoodsInfoDo) FirstOrCreate() (*model.ProductGoodsInfo, error) {
	if result, err := p.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ProductGoodsInfo), nil
	}
}

func (p productGoodsInfoDo) FindByPage(offset int, limit int) (result []*model.ProductGoodsInfo, count int64, err error) {
	result, err = p.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = p.Offset(-1).Limit(-1).Count()
	return
}

func (p productGoodsInfoDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = p.Count()
	if err != nil {
		return
	}

	err = p.Offset(offset).Limit(limit).Scan(result)
	return
}

func (p productGoodsInfoDo) Scan(result interface{}) (err error) {
	return p.DO.Scan(result)
}

func (p productGoodsInfoDo) Delete(models ...*model.ProductGoodsInfo) (result gen.ResultInfo, err error) {
	return p.DO.Delete(models)
}

func (p *productGoodsInfoDo) withDO(do gen.Dao) *productGoodsInfoDo {
	p.DO = *do.(*gen.DO)
	return p
}
